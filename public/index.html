<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="Share files, images, videos, and text with the community" />
  <meta name="theme-color" content="#00d4ff" />
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" type="image/png" href="/icon.png">
  <link rel="stylesheet" href="style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <title>Nafij's Social Share</title>
</head>
<body>
  <!-- Offline Banner -->
  <div id="offline-banner" class="offline-banner" role="alert" aria-live="polite">
    <div class="offline-content">
      <span class="offline-icon">üì°</span>
      <div>
        <strong>You're offline</strong>
        <small>Posts will be synced when connection is restored</small>
        <div id="offline-count" class="offline-count"></div>
      </div>
    </div>
  </div>

  <!-- Install Banner -->
  <div id="install-banner" class="install-banner" role="banner">
    <span>üì± Install this app for a better experience!</span>
    <div>
      <button id="install-btn" class="btn-outline" aria-label="Install app">Install</button>
      <button id="dismiss-install" class="btn-outline" aria-label="Dismiss install prompt">Dismiss</button>
    </div>
  </div>

  <!-- Header -->
  <header class="header" role="banner">
    <h1>üöÄ Nafij's Social Share</h1>
    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
      <span id="theme-icon">üåô</span>
    </button>
  </header>

  <!-- Main Content -->
  <main class="container" role="main">
    <!-- Post Creation Form -->
    <section class="card post-form-card fade-in" aria-labelledby="post-heading">
      <h2 id="post-heading">Share Something Amazing</h2>
      <form id="post-form" method="POST" action="/api/posts" enctype="multipart/form-data" role="form">
        <div class="form-group">
          <label for="username">Username (max 20 chars) *</label>
          <input 
            type="text" 
            id="username" 
            name="user" 
            placeholder="Enter your username" 
            maxlength="20" 
            required 
            aria-describedby="username-help"
          />
          <small id="username-help">Your username will be saved for future posts</small>
        </div>

        <div class="form-group">
          <label for="post-text">What's on your mind?</label>
          <textarea 
            id="post-text" 
            name="text" 
            placeholder="Share your thoughts, use emojis! üéâ" 
            rows="4"
            aria-describedby="text-help"
          ></textarea>
          <small id="text-help">Supports emojis and multi-line text</small>
        </div>

        <div class="form-group">
          <label for="file-input">Upload Files</label>
          <div class="file-upload-area" id="file-upload-area">
            <input 
              type="file" 
              id="file-input" 
              name="file" 
              multiple 
              accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.txt,.zip,.rar"
              aria-describedby="file-help"
            />
            <div class="file-upload-text">
              <span>üìé Drag & drop files here or click to browse</span>
              <small>Max 50MB per file ‚Ä¢ Images, videos, audio, documents supported</small>
            </div>
          </div>
          <small id="file-help">Multiple files supported ‚Ä¢ Max 50MB per file ‚Ä¢ Total 200MB per post</small>
        </div>

        <div id="file-previews" class="file-previews"></div>

        <div id="upload-progress" class="upload-progress" style="display: none;" role="progressbar" aria-live="polite">
          <div class="progress-bar">
            <div class="progress-fill"></div>
          </div>
          <div class="progress-info">
            <span class="progress-text">Uploading...</span>
            <span class="progress-percentage">0%</span>
          </div>
          <button type="button" id="cancel-upload" class="btn-outline">Cancel</button>
        </div>

        <button type="submit" class="btn btn-primary" id="submit-btn">
          <span>üöÄ Share Post</span>
        </button>
      </form>
    </section>

    <!-- Navigation -->
    <nav class="card navigation-card" role="navigation" aria-label="Site navigation">
      <div class="nav-buttons">
        <button class="btn btn-secondary active" data-view="feed">üìã Feed</button>
        <button class="btn btn-outline" data-view="all">üåê All Posts</button>
        <a href="/info" class="btn btn-outline">‚ÑπÔ∏è About</a>
        <a href="/admin" class="btn btn-outline">‚öôÔ∏è Admin</a>
      </div>
    </nav>

    <!-- Feed Section -->
    <section class="feed-section" id="feed-section" aria-labelledby="feed-heading">
      <h3 id="feed-heading">Live Feed</h3>
      <div id="posts-feed" class="posts-container" role="feed" aria-live="polite">
        <div class="loading-skeleton">
          <div class="skeleton-post"></div>
          <div class="skeleton-post"></div>
          <div class="skeleton-post"></div>
        </div>
      </div>
      <div id="load-more" class="load-more" style="display: none;">
        <button class="btn btn-outline">Load More Posts</button>
      </div>
    </section>
  </main>

  <!-- Scroll to Top Button -->
  <button class="scroll-top" id="scroll-top" aria-label="Scroll to top">
    ‚Üë
  </button>

  <!-- Lightbox Modal -->
  <div id="lightbox" class="lightbox" role="dialog" aria-modal="true" aria-labelledby="lightbox-title">
    <div class="lightbox-content">
      <button class="lightbox-close" aria-label="Close lightbox">&times;</button>
      <div class="lightbox-media"></div>
      <div class="lightbox-controls">
        <button class="btn btn-outline" id="lightbox-download">‚¨áÔ∏è Download</button>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script>
    // Global state
    let currentPage = 0;
    let isLoading = false;
    let allPosts = [];
    let currentView = 'feed';
    let deferredPrompt;
    let uploadController = null;
    let socket;
    let currentUser = null;
    const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
    const MAX_TOTAL_SIZE = 200 * 1024 * 1024; // 200MB

    // Check authentication
    function checkAuth() {
      const token = localStorage.getItem('token');
      if (!token) {
        window.location.href = '/auth.html';
        return false;
      }
      return true;
    }

    // Initialize socket connection
    function initSocket() {
      const token = localStorage.getItem('token');
      if (!token) return;

      socket = io();
      
      socket.on('connect', () => {
        console.log('Connected to server');
        socket.emit('authenticate', token);
      });

      socket.on('authenticated', (data) => {
        console.log('Authenticated as:', data.user);
      });

      socket.on('newPost', (post) => {
        // Add new post to feed
        const container = document.getElementById('posts-feed');
        const postElement = createPostElement(post);
        postElement.classList.add('new-post');
        container.insertBefore(postElement, container.firstChild);
        
        setTimeout(() => {
          postElement.classList.add('fade-in');
          postElement.classList.remove('new-post');
        }, 100);
        
        showNotification('New post added! üéâ', 'success');
      });

      socket.on('postLiked', (data) => {
        const postElement = document.querySelector(`[data-post-id="${data.postId}"]`);
        if (postElement) {
          const likeCount = postElement.querySelector('.like-count');
          if (likeCount) {
            likeCount.textContent = data.likes;
          }
        }
      });

      socket.on('postDeleted', (data) => {
        const postElement = document.querySelector(`[data-post-id="${data.postId}"]`);
        if (postElement) {
          postElement.classList.add('fade-out');
          setTimeout(() => postElement.remove(), 300);
        }
      });
    }

    // Get current user info
    async function getCurrentUser() {
      const token = localStorage.getItem('token');
      if (!token) return null;

      try {
        const response = await fetch('/api/auth/me', {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        if (response.ok) {
          const data = await response.json();
          currentUser = data.user;
          return data.user;
        }
      } catch (error) {
        console.error('Error getting current user:', error);
      }
      return null;
    }

    // Theme Management
    const themeToggle = document.getElementById('theme-toggle');
    const themeIcon = document.getElementById('theme-icon');
    const body = document.body;

    // Load saved theme
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark' || (!savedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      body.classList.add('dark');
      themeIcon.textContent = '‚òÄÔ∏è';
    }

    themeToggle.addEventListener('click', () => {
      body.classList.toggle('dark');
      const isDark = body.classList.contains('dark');
      themeIcon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
    });

    // Username Management
    const usernameInput = document.getElementById('username');
    const savedUsername = localStorage.getItem('username');
    if (savedUsername) {
      usernameInput.value = savedUsername;
    }

    usernameInput.addEventListener('input', (e) => {
      localStorage.setItem('username', e.target.value);
    });

    // File Upload Handling
    const fileInput = document.getElementById('file-input');
    const fileUploadArea = document.getElementById('file-upload-area');
    const filePreviewsContainer = document.getElementById('file-previews');
    let selectedFiles = [];

    // Drag and drop functionality
    fileUploadArea.addEventListener('dragover', (e) => {
      e.preventDefault();
      fileUploadArea.classList.add('drag-over');
    });

    fileUploadArea.addEventListener('dragleave', () => {
      fileUploadArea.classList.remove('drag-over');
    });

    fileUploadArea.addEventListener('drop', (e) => {
      e.preventDefault();
      fileUploadArea.classList.remove('drag-over');
      const files = Array.from(e.dataTransfer.files);
      handleFileSelection(files);
    });

    fileInput.addEventListener('change', (e) => {
      const files = Array.from(e.target.files);
      handleFileSelection(files);
    });

    function handleFileSelection(files) {
      // Validate file sizes
      const validFiles = [];
      let totalSize = selectedFiles.reduce((sum, file) => sum + file.size, 0);
      
      for (const file of files) {
        if (file.size > MAX_FILE_SIZE) {
          showNotification(`File "${file.name}" is too large. Max size is 50MB.`, 'error');
          continue;
        }
        
        if (totalSize + file.size > MAX_TOTAL_SIZE) {
          showNotification(`Total file size would exceed 200MB limit.`, 'error');
          break;
        }
        
        validFiles.push(file);
        totalSize += file.size;
      }
      
      selectedFiles = [...selectedFiles, ...validFiles];
      displayFilePreviews();
    }

    function displayFilePreviews() {
      filePreviewsContainer.innerHTML = '';
      
      if (selectedFiles.length === 0) return;
      
      selectedFiles.forEach((file, index) => {
        const preview = document.createElement('div');
        preview.className = 'file-preview';
        
        // Add file size info
        const fileSize = formatFileSize(file.size);
        
        if (file.type.startsWith('image/')) {
          const img = document.createElement('img');
          img.src = URL.createObjectURL(file);
          img.alt = file.name;
          img.onload = () => URL.revokeObjectURL(img.src);
          preview.appendChild(img);
        } else if (file.type.startsWith('video/')) {
          const video = document.createElement('video');
          video.src = URL.createObjectURL(file);
          video.controls = true;
          video.onloadeddata = () => URL.revokeObjectURL(video.src);
          preview.appendChild(video);
        } else if (file.type.startsWith('audio/')) {
          const audio = document.createElement('audio');
          audio.src = URL.createObjectURL(file);
          audio.controls = true;
          audio.onloadeddata = () => URL.revokeObjectURL(audio.src);
          preview.appendChild(audio);
        } else {
          const fileIcon = document.createElement('div');
          fileIcon.className = 'file-icon';
          fileIcon.textContent = 'üìÑ';
          preview.appendChild(fileIcon);
        }

        const fileName = document.createElement('span');
        fileName.className = 'file-name';
        fileName.textContent = `${file.name} (${fileSize})`;
        preview.appendChild(fileName);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'file-remove';
        removeBtn.textContent = '√ó';
        removeBtn.setAttribute('aria-label', `Remove ${file.name}`);
        removeBtn.onclick = () => removeFile(index);
        preview.appendChild(removeBtn);

        filePreviewsContainer.appendChild(preview);
      });
    }

    function removeFile(index) {
      selectedFiles.splice(index, 1);
      displayFilePreviews();
    }

    // Form submission
    const postForm = document.getElementById('post-form');
    const submitBtn = document.getElementById('submit-btn');
    const progressContainer = document.getElementById('upload-progress');
    const progressFill = document.querySelector('.progress-fill');
    const progressText = document.querySelector('.progress-text');
    const progressPercentage = document.querySelector('.progress-percentage');
    const cancelBtn = document.getElementById('cancel-upload');
    
    postForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      if (!checkAuth()) return;
      
      if (selectedFiles.length === 0 && !document.getElementById('post-text').value.trim()) {
        showNotification('Please add some content or files to share.', 'warning');
        return;
      }
      
      const formData = new FormData();
      formData.append('text', document.getElementById('post-text').value);
      
      if (selectedFiles.length > 0) {
        selectedFiles.forEach(file => {
          formData.append('files', file);
        });
      }

      submitBtn.innerHTML = '<span>üöÄ Posting...</span>';
      submitBtn.disabled = true;
      
      // Show progress bar
      progressContainer.style.display = 'block';
      
      // Create abort controller for cancellation
      uploadController = new AbortController();

      try {
        const xhr = new XMLHttpRequest();
        
        // Upload progress tracking
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percentComplete = (e.loaded / e.total) * 100;
            progressFill.style.width = percentComplete + '%';
            progressPercentage.textContent = Math.round(percentComplete) + '%';
            progressText.textContent = `Uploading... ${formatFileSize(e.loaded)} / ${formatFileSize(e.total)}`;
          }
        });
        
        // Handle completion
        xhr.addEventListener('load', () => {
          if (xhr.status === 200) {
            postForm.reset();
            selectedFiles = [];
            displayFilePreviews();
            loadPosts(true);
            showNotification('Post shared successfully! üéâ', 'success');
          } else {
            throw new Error('Upload failed');
          }
        });
        
        xhr.addEventListener('error', () => {
          throw new Error('Network error during upload');
        });
        
        xhr.addEventListener('abort', () => {
          showNotification('Upload cancelled', 'info');
        });
        
        // Setup request
        xhr.open('POST', '/api/posts');
        xhr.setRequestHeader('Authorization', `Bearer ${localStorage.getItem('token')}`);
        xhr.send(formData);
        
        // Handle cancellation
        cancelBtn.onclick = () => {
          xhr.abort();
          uploadController.abort();
        };
        
      } catch (error) {
        console.error('Error posting:', error);
        
        if (error.name === 'AbortError') {
          showNotification('Upload cancelled', 'info');
        } else if (!navigator.onLine) {
          showNotification('Posted offline. Will sync when connection is restored.', 'warning');
        } else {
          showNotification('Failed to post. Please try again.', 'error');
        }
      } finally {
        submitBtn.innerHTML = '<span>üöÄ Share Post</span>';
        submitBtn.disabled = false;
        progressContainer.style.display = 'none';
        uploadController = null;
      }
    });
    
    // Cancel upload functionality
    cancelBtn.addEventListener('click', () => {
      if (uploadController) {
        uploadController.abort();
      }
    });

    // Utility function to format file sizes
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Posts loading and display
    async function loadPosts(refresh = false) {
      if (isLoading) return;
      isLoading = true;

      if (refresh) {
        currentPage = 0;
        allPosts = [];
      }

      try {
        const headers = {};
        const token = localStorage.getItem('token');
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        }
        
        const response = await fetch(`/api/posts?page=${currentPage}&limit=10`, { headers });
        const posts = await response.json();
        
        if (refresh) {
          allPosts = posts;
        } else {
          allPosts = [...allPosts, ...posts];
        }
        
        displayPosts(posts, refresh);
        currentPage++;
        
        // Show load more button if there are more posts
        const loadMoreBtn = document.getElementById('load-more');
        if (posts.length === 10) {
          loadMoreBtn.style.display = 'block';
        } else {
          loadMoreBtn.style.display = 'none';
        }
      } catch (error) {
        console.error('Error loading posts:', error);
        showNotification('Failed to load posts', 'error');
      } finally {
        isLoading = false;
      }
    }

    function displayPosts(posts, refresh = false) {
      const container = document.getElementById('posts-feed');
      
      if (refresh) {
        container.innerHTML = '';
      }

      if (posts.length === 0 && refresh) {
        container.innerHTML = '<div class="empty-state">No posts yet. Be the first to share something! üöÄ</div>';
        return;
      }

      posts.forEach(post => {
        const postElement = createPostElement(post);
        container.appendChild(postElement);
        
        // Animate in
        setTimeout(() => {
          postElement.classList.add('fade-in');
        }, 100);
      });
    }

    function createPostElement(post) {
      const postDiv = document.createElement('article');
      postDiv.className = 'post-card';
      postDiv.setAttribute('data-post-id', post._id);

      const timeAgo = getTimeAgo(new Date(post.createdAt));
      const canDelete = currentUser && post.userId._id === currentUser.id;
      const isPremium = post.userId?.isPremium || false;

      let mediaHTML = '';
      if (post.media && post.media.length > 0) {
        mediaHTML = post.media.map(file => {
          const mediaUrl = file.url;
          
          if (file.mimetype?.startsWith('image/')) {
            return `
              <div class="post-media">
                <img src="${mediaUrl}" alt="Post image" onclick="openLightbox('${mediaUrl}', 'image')" />
                <button class="media-download" onclick="downloadFile('${mediaUrl}', '${file.originalName}')" aria-label="Download image">‚¨áÔ∏è</button>
              </div>
            `;
          } else if (file.mimetype?.startsWith('video/')) {
            return `
              <div class="post-media">
                <video controls preload="metadata">
                  <source src="${mediaUrl}" type="${file.mimetype}">
                  Your browser does not support the video tag.
                </video>
                <button class="media-download" onclick="downloadFile('${mediaUrl}', '${file.originalName}')" aria-label="Download video">‚¨áÔ∏è</button>
              </div>
            `;
          } else if (file.mimetype?.startsWith('audio/')) {
            return `
              <div class="post-media">
                <audio controls preload="metadata">
                  <source src="${mediaUrl}" type="${file.mimetype}">
                  Your browser does not support the audio tag.
                </audio>
                <button class="media-download" onclick="downloadFile('${mediaUrl}', '${file.originalName}')" aria-label="Download audio">‚¨áÔ∏è</button>
              </div>
            `;
          } else {
            return `
              <div class="post-media">
                <a href="${mediaUrl}" download target="_blank" class="file-attachment" aria-label="Download file">
                  üìé Download ${file.originalName}
                </a>
              </div>
            `;
          }
        }).join('');
        }
      }

      postDiv.innerHTML = `
        <div class="post-header">
          <div class="post-author">
            <strong onclick="viewUserProfile('${post.userId.username}')" style="cursor: pointer;">
              ${post.userId.username || 'Anonymous'}
              ${isPremium ? '<span class="premium-badge">‚ú® Premium</span>' : ''}
            </strong>
            <span class="post-time">${timeAgo}</span>
          </div>
          ${canDelete ? `<button class="post-delete" onclick="deletePost('${post._id}')" aria-label="Delete post">üóëÔ∏è</button>` : ''}
        </div>
        
        ${post.text ? `<div class="post-content">${post.text}</div>` : ''}
        
        ${mediaHTML}
        
        <div class="post-actions">
          <button class="like-btn ${post.userLiked ? 'liked' : ''}" onclick="toggleLike('${post._id}')">
            <span class="reaction-icon">‚ù§Ô∏è</span>
            <span class="like-count">${post.likes || 0}</span>
          </button>
          
          <div class="reactions-dropdown">
            <button class="reactions-btn" onclick="toggleReactions('${post._id}')">
              <span class="reaction-icon">üòä</span>
              <span class="reactions-count">${(post.reactions?.total || 0)}</span>
            </button>
            <div class="reactions-menu" id="reactions-${post._id}">
              <button onclick="addReaction('${post._id}', 'love')" class="reaction-option">‚ù§Ô∏è</button>
              <button onclick="addReaction('${post._id}', 'laugh')" class="reaction-option">üòÇ</button>
              <button onclick="addReaction('${post._id}', 'like')" class="reaction-option">üëç</button>
              <button onclick="addReaction('${post._id}', 'wow')" class="reaction-option">üòÆ</button>
              <button onclick="addReaction('${post._id}', 'sad')" class="reaction-option">üò¢</button>
              <button onclick="addReaction('${post._id}', 'angry')" class="reaction-option">üò†</button>
            </div>
          </div>
          
          <button class="comment-btn" onclick="toggleComments('${post._id}')">
            üí¨ <span class="comment-count">${post.comments?.length || 0}</span>
          </button>
          
          <button class="share-btn" onclick="sharePost('${post._id}')">
            üîó Share
          </button>
        </div>
        
        <div class="comments-section" id="comments-${post._id}" style="display: none;">
          <div class="comments-list" id="comments-list-${post._id}">
            ${(post.comments || []).map(comment => createCommentHTML(comment, post._id, 0)).join('')}
          </div>
          
          <div class="comment-form">
            <input type="text" placeholder="Add a comment..." class="comment-input" value="${localStorage.getItem('username') || ''}"
                   onkeypress="handleCommentSubmit(event, '${post._id}')" />
            <button onclick="submitComment('${post._id}')" class="btn btn-outline">Post</button>
          </div>
        </div>
      `;

      return postDiv;
    }

    // View user profile
    function viewUserProfile(username) {
      window.location.href = `/profile.html?user=${username}`;
    }

    function createCommentHTML(comment, postId, level = 0) {
      const timeAgo = getTimeAgo(new Date(comment.createdAt));
      const canDelete = currentUser && comment.userId._id === currentUser.id;
      const maxLevel = 3;
      const indent = level * 20;
      const isPremium = comment.userId?.isPremium || false;
      
      return `
        <div class="comment level-${level}" data-comment-id="${comment._id}" style="margin-left: ${indent}px;">
          <div class="comment-header">
            <strong onclick="viewUserProfile('${comment.userId.username}')" style="cursor: pointer;">
              ${comment.userId.username || 'Anonymous'}
              ${isPremium ? '<span class="premium-badge">‚ú®</span>' : ''}
            </strong>
            <span class="comment-time">${timeAgo}</span>
            ${canDelete ? `<button class="comment-delete" onclick="deleteComment('${comment._id}')" aria-label="Delete comment">üóëÔ∏è</button>` : ''}
          </div>
          <div class="comment-content">${comment.text}</div>
          <div class="comment-actions">
            <button class="like-btn ${comment.userLiked ? 'liked' : ''}" onclick="toggleCommentLike('${comment._id}', '${postId}')">
              <span class="reaction-icon">‚ù§Ô∏è</span>
              <span class="like-count">${comment.likes || 0}</span>
            </button>
            ${level < maxLevel ? `<button class="reply-btn" onclick="showReplyForm('${comment._id}', '${postId}')">‚Ü©Ô∏è Reply</button>` : ''}
          </div>
          <div class="reply-form" id="reply-form-${comment._id}" style="display: none;">
            <input type="text" placeholder="Write a reply..." class="reply-input" 
                   onkeypress="handleReplySubmit(event, '${comment._id}', '${postId}')" />
            <button onclick="submitReply('${comment._id}', '${postId}')" class="btn btn-outline">Reply</button>
            <button onclick="hideReplyForm('${comment._id}')" class="btn btn-outline">Cancel</button>
          </div>
          <div class="replies" id="replies-${comment._id}">
            ${(comment.replies || []).map(reply => createCommentHTML(reply, postId, level + 1)).join('')}
          </div>
        </div>
      `;
    }

    // Post interactions
    async function toggleLike(postId) {
      if (!checkAuth()) return;
      
      try {
        const response = await fetch(`/api/posts/${postId}/like`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        });
        
        if (response.ok) {
          const result = await response.json();
          const likeBtn = document.querySelector(`[data-post-id="${postId}"] .like-btn`);
          const likeCount = likeBtn.querySelector('.like-count');
          
          if (result.liked) {
            likeBtn.classList.add('liked');
          } else {
            likeBtn.classList.remove('liked');
          }
          likeCount.textContent = result.likes;
          
          // Animate heart
          likeBtn.classList.add('pulse');
          setTimeout(() => likeBtn.classList.remove('pulse'), 300);
        }
      } catch (error) {
        console.error('Error liking post:', error);
      }
    }

    async function addReaction(postId, reactionType) {
      if (!checkAuth()) return;
      
      try {
        const response = await fetch(`/api/posts/${postId}/reactions`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          },
          body: JSON.stringify({
            type: reactionType
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          updateReactionsDisplay(postId, result.reactions);
          hideReactions(postId);
        }
      } catch (error) {
        console.error('Error adding reaction:', error);
      }
    }

    function toggleReactions(postId) {
      const menu = document.getElementById(`reactions-${postId}`);
      const isVisible = menu.style.display === 'block';
      
      // Hide all other reaction menus
      document.querySelectorAll('.reactions-menu').forEach(m => m.style.display = 'none');
      
      menu.style.display = isVisible ? 'none' : 'block';
    }

    function hideReactions(postId) {
      document.getElementById(`reactions-${postId}`).style.display = 'none';
    }

    function updateReactionsDisplay(postId, reactions) {
      const reactionsBtn = document.querySelector(`[data-post-id="${postId}"] .reactions-count`);
      reactionsBtn.textContent = reactions.total || 0;
    }

    function toggleComments(postId) {
      const commentsSection = document.getElementById(`comments-${postId}`);
      const isVisible = commentsSection.style.display !== 'none';
      
      commentsSection.style.display = isVisible ? 'none' : 'block';
      
      if (!isVisible) {
        commentsSection.classList.add('slide-in');
      }
    }

    function handleCommentSubmit(event, postId) {
      if (event.key === 'Enter') {
        submitComment(postId);
      }
    }

    async function submitComment(postId) {
      if (!checkAuth()) return;
      
      const input = document.querySelector(`#comments-${postId} .comment-input`);
      const text = input.value.trim();
      
      if (!text) return;
      
      try {
        const response = await fetch(`/api/posts/${postId}/comments`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          },
          body: JSON.stringify({
            text: text
          })
        });
        
        if (response.ok) {
          input.value = '';
          // Refresh comments or add new comment to DOM
          loadPosts(true);
        }
      } catch (error) {
        console.error('Error posting comment:', error);
      }
    }

    function showReplyForm(commentId, postId) {
      const replyForm = document.getElementById(`reply-form-${commentId}`);
      const replyInput = replyForm.querySelector('.reply-input');
      
      replyForm.style.display = 'block';
      replyInput.focus();
      replyInput.value = localStorage.getItem('username') || '';
    }

    function hideReplyForm(commentId) {
      document.getElementById(`reply-form-${commentId}`).style.display = 'none';
    }

    function handleReplySubmit(event, commentId, postId) {
      if (event.key === 'Enter') {
        submitReply(commentId, postId);
      }
    }

    async function submitReply(commentId, postId) {
      if (!checkAuth()) return;
      
      const input = document.querySelector(`#reply-form-${commentId} .reply-input`);
      const text = input.value.trim();
      
      if (!text) return;
      
      try {
        const response = await fetch(`/api/posts/${postId}/comments/${commentId}/replies`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          },
          body: JSON.stringify({
            text: text
          })
        });
        
        if (response.ok) {
          input.value = '';
          hideReplyForm(commentId);
          loadPosts(true); // Refresh to show new reply
        }
      } catch (error) {
        console.error('Error posting reply:', error);
      }
    }

    async function toggleCommentLike(commentId, postId) {
      if (!checkAuth()) return;
      
      try {
        const response = await fetch(`/api/posts/${postId}/comments/${commentId}/like`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${localStorage.getToken('token')}`
          }
        });
        
        if (response.ok) {
          const result = await response.json();
          const likeBtn = document.querySelector(`[data-comment-id="${commentId}"] .like-btn`);
          const likeCount = likeBtn.querySelector('.like-count');
          
          likeBtn.classList.add('liked');
          likeCount.textContent = result.likes;
          
          // Animate heart
          likeBtn.classList.add('pulse');
          setTimeout(() => likeBtn.classList.remove('pulse'), 300);
        }
      } catch (error) {
        console.error('Error liking comment:', error);
      }
    }

    async function deletePost(postId) {
      if (!checkAuth()) return;
      
      if (!confirm('Are you sure you want to delete this post?')) return;
      
      try {
        const response = await fetch(`/api/posts/${postId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`
          }
        });
        
        if (response.ok) {
          const postElement = document.querySelector(`[data-post-id="${postId}"]`);
          postElement.classList.add('fade-out');
          setTimeout(() => postElement.remove(), 300);
          showNotification('Post deleted successfully', 'success');
        }
      } catch (error) {
        console.error('Error deleting post:', error);
        showNotification('Failed to delete post', 'error');
      }
    }

    function sharePost(postId) {
      const url = `${window.location.origin}#post-${postId}`;
      
      if (navigator.share) {
        navigator.share({
          title: 'Check out this post',
          url: url
        });
      } else {
        navigator.clipboard.writeText(url).then(() => {
          showNotification('Link copied to clipboard!', 'success');
        });
      }
    }

    // Lightbox functionality
    function openLightbox(src, type) {
      const lightbox = document.getElementById('lightbox');
      const mediaContainer = lightbox.querySelector('.lightbox-media');
      
      if (type === 'image') {
        mediaContainer.innerHTML = `<img src="${src}" alt="Lightbox image" />`;
      } else if (type === 'video') {
        mediaContainer.innerHTML = `
          <video controls autoplay>
            <source src="${src}" type="video/mp4">
            Your browser does not support the video tag.
          </video>
        `;
      }
      
      lightbox.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      
      // Set download link
      const filename = src.split('/').pop();
      document.getElementById('lightbox-download').onclick = () => downloadFile(src, filename);
    }

    function closeLightbox() {
      const lightbox = document.getElementById('lightbox');
      lightbox.style.display = 'none';
      document.body.style.overflow = 'auto';
    }

    // Close lightbox on click outside or escape key
    document.getElementById('lightbox').addEventListener('click', (e) => {
      if (e.target.id === 'lightbox') closeLightbox();
    });

    document.querySelector('.lightbox-close').addEventListener('click', closeLightbox);

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeLightbox();
    });

    function downloadFile(url, filename) {
      const a = document.createElement('a');
      a.href = url;
      a.download = filename || url.split('/').pop() || 'download';
      a.target = '_blank';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      showNotification('Download started', 'success');
    }

    // Utility functions
    function getTimeAgo(date) {
      const now = new Date();
      const diffInSeconds = Math.floor((now - date) / 1000);
      
      if (diffInSeconds < 60) return 'just now';
      if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
      if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
      if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)}d ago`;
      
      return date.toLocaleDateString();
    }

    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.classList.add('show');
      }, 100);
      
      setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    // Scroll to Top Button
    const scrollTopBtn = document.getElementById('scroll-top');
    
    window.addEventListener('scroll', () => {
      if (window.pageYOffset > 300) {
        scrollTopBtn.classList.add('visible');
      } else {
        scrollTopBtn.classList.remove('visible');
      }
    });

    scrollTopBtn.addEventListener('click', () => {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });

    // Infinite scroll
    window.addEventListener('scroll', () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 1000) {
        loadPosts();
      }
    });

    // Load more button
    document.getElementById('load-more').addEventListener('click', () => {
      loadPosts();
    });

    // Online/Offline Status
    const offlineBanner = document.getElementById('offline-banner');
    const offlineCount = document.getElementById('offline-count');
    
    function updateOfflineStatus() {
      if (navigator.onLine) {
        offlineBanner.classList.remove('show');
      } else {
        offlineBanner.classList.add('show');
        updateOfflineCount();
      }
    }
    
    function updateOfflineCount() {
      if ('serviceWorker' in navigator) {
        const channel = new MessageChannel();
        channel.port1.onmessage = (event) => {
          const count = event.data.count;
          if (count > 0) {
            offlineCount.textContent = `${count} post${count > 1 ? 's' : ''} pending sync`;
            offlineCount.style.display = 'block';
          } else {
            offlineCount.style.display = 'none';
          }
        };
        
        navigator.serviceWorker.controller?.postMessage(
          { type: 'GET_OFFLINE_COUNT' },
          [channel.port2]
        );
      }
    }
    
    window.addEventListener('online', () => {
      updateOfflineStatus();
      showNotification('Back online! üåê', 'success');
      // Trigger background sync
      if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
        navigator.serviceWorker.ready.then(registration => {
          return registration.sync.register('background-post');
        });
      }
    });

    window.addEventListener('offline', () => {
      updateOfflineStatus();
      showNotification('You are offline üì°', 'warning');
    });
    
    // Initial offline status check
    updateOfflineStatus();

    // PWA Install Prompt
    const installBanner = document.getElementById('install-banner');
    const installBtn = document.getElementById('install-btn');
    const dismissBtn = document.getElementById('dismiss-install');

    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      
      if (!localStorage.getItem('install-dismissed')) {
        installBanner.classList.add('show');
      }
    });

    installBtn.addEventListener('click', async () => {
      if (deferredPrompt) {
        deferredPrompt.prompt();
        const { outcome } = await deferredPrompt.userChoice;
        deferredPrompt = null;
        installBanner.classList.remove('show');
        
        if (outcome === 'accepted') {
          showNotification('App installed successfully! üéâ', 'success');
        }
      }
    });

    dismissBtn.addEventListener('click', () => {
      installBanner.classList.remove('show');
      localStorage.setItem('install-dismissed', 'true');
    });

    // Service Worker Registration
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(registration => {
          console.log('SW registered:', registration);
          
          // Listen for updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                showNotification('New version available! Refresh to update.', 'info');
              }
            });
          });
        })
        .catch(error => {
          console.log('SW registration failed:', error);
        });

      // Listen for messages from service worker
      navigator.serviceWorker.addEventListener('message', (event) => {
        const { data } = event.data;
        
        if (data.type === 'SYNC_COMPLETE') {
          showNotification(data.message, 'success');
          updateOfflineCount();
          loadPosts(true); // Refresh feed after sync
        }
        
        if (data.type === 'NEW_CONTENT') {
          if (data.count > 0) {
            showNotification(`${data.count} new post${data.count > 1 ? 's' : ''} available`, 'info');
          }
        }
      });
    }

    // Real-time updates (polling every 15 seconds)
    setInterval(() => {
      if (navigator.onLine && currentView === 'feed') {
        checkForNewPosts();
      }
    }, 15000);

    let lastPostTime = new Date();

    async function checkForNewPosts() {
      try {
        const response = await fetch(`/api/posts/new?since=${lastPostTime.toISOString()}`);
        const newPosts = await response.json();
        
        if (newPosts.length > 0) {
          const container = document.getElementById('posts-feed');
          
          newPosts.reverse().forEach(post => {
            const postElement = createPostElement(post);
            postElement.classList.add('new-post');
            container.insertBefore(postElement, container.firstChild);
            
            // Animate in
            setTimeout(() => {
              postElement.classList.add('fade-in');
              postElement.classList.remove('new-post');
            }, 100);
          });
          
          lastPostTime = new Date(newPosts[0].createdAt);
          showNotification(`${newPosts.length} new post${newPosts.length > 1 ? 's' : ''} added! üéâ`, 'success');
        }
      } catch (error) {
        console.error('Error checking for new posts:', error);
      }
    }

    // Initialize app
    document.addEventListener('DOMContentLoaded', () => {
      // Check if user is logged in
      const token = localStorage.getItem('token');
      if (!token) {
        window.location.href = '/auth.html';
        return;
      }
      
      // Initialize user and socket
      getCurrentUser().then(user => {
        if (user) {
          // Update username input with current user
          usernameInput.value = user.username;
          usernameInput.disabled = true;
          
          // Initialize socket connection
          initSocket();
        } else {
          // Invalid token, redirect to auth
          localStorage.removeItem('token');
          localStorage.removeItem('user');
          window.location.href = '/auth.html';
          return;
        }
      });
      
      loadPosts(true);
      lastPostTime = new Date();
      updateOfflineStatus();
      
      // Add intersection observer for animations
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('fade-in');
          }
        });
      });

      // Observe all cards for animation
      document.querySelectorAll('.card').forEach(card => {
        observer.observe(card);
      });
      
      // Update offline count periodically
      setInterval(updateOfflineCount, 30000); // Every 30 seconds
      
      // Close reactions menu when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.reactions-dropdown')) {
          document.querySelectorAll('.reactions-menu').forEach(menu => {
            menu.style.display = 'none';
          });
        }
      });
      
      // Add navigation buttons
      const navButtons = document.querySelector('.nav-buttons');
      navButtons.innerHTML += `
        <a href="/chat.html" class="btn btn-outline">üí¨ Chat</a>
        <a href="/search.html" class="btn btn-outline">üîç Search</a>
        <button class="btn btn-outline" onclick="logout()">üö™ Logout</button>
      `;
    });
    
    // Logout function
    function logout() {
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      localStorage.removeItem('username');
      if (socket) {
        socket.disconnect();
      }
      window.location.href = '/auth.html';
    }
  </script>
</body>
</html>